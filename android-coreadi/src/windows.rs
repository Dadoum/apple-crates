#![allow(unsafe_op_in_unsafe_fn)]
#![allow(non_camel_case_types)]

// TODO: finish that

use crate::linux_libc::*;
use elf_loader::linux_cc;
use std::ffi::{CStr, CString};
use std::mem;
use std::mem::MaybeUninit;

pub type __time32_t = libc::c_long;
pub type __time64_t = libc::c_longlong;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: libc::c_long,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: libc::c_long,
}

// Import a few windows functions that are not defined in libc
unsafe extern "C" {
    fn _errno() -> *mut libc::c_int;
    fn _timespec64_get(__ts: *mut _timespec64, __base: libc::c_int) -> libc::c_int;
    fn _timespec32_get(__ts: *mut _timespec32, __base: libc::c_int) -> libc::c_int;
    fn _chsize(handle: i64, length: u64) -> usize;
}

#[linux_cc]
pub unsafe fn chmod(path: *const libc::c_char, mode: mode_t) -> libc::c_int {
    libc::chmod(linux_path_to_windows(path).as_ptr(), mem::transmute(mode))
}

#[linux_cc]
pub unsafe fn close(fd: libc::c_int) -> libc::c_int {
    libc::close(fd)
}

#[linux_cc]
pub unsafe fn errno() -> *mut libc::c_int {
    // HACK we should also translate the errnos, but eh it works fine right now
    _errno()
}

#[linux_cc]
pub unsafe fn free(p: *mut libc::c_void) {
    libc::free(p)
}

#[linux_cc]
pub unsafe fn ftruncate(handle: i64, length: u64) -> usize {
    _chsize(handle, length)
}

#[linux_cc]
pub unsafe fn gettimeofday(tp: *mut timeval, tz: *mut libc::c_void) -> libc::c_int {
    let mut time = MaybeUninit::uninit();

    #[cfg(target_pointer_width = "32")]
    let result = _timespec32_get(time.as_mut_ptr(), 1);
    #[cfg(target_pointer_width = "64")]
    let result = _timespec64_get(time.as_mut_ptr(), 1);

    let time = time.assume_init();
    *tp = timeval {
        tv_sec: time.tv_sec as _,
        tv_usec: (time.tv_nsec / 1000) as _,
    };

    if result == 1 { 0 } else { 1 }
}

#[linux_cc]
pub unsafe fn malloc(size: libc::size_t) -> *mut libc::c_void {
    libc::malloc(size)
}

#[linux_cc]
pub unsafe fn mkdir(path: *const libc::c_char, mode: mode_t) -> libc::c_int {
    libc::mkdir(linux_path_to_windows(path).as_ptr())
}

#[linux_cc]
pub unsafe fn read(fd: libc::c_int, buf: *mut libc::c_void, count: libc::c_uint) -> libc::c_int {
    libc::read(fd, buf, count)
}

#[linux_cc]
pub unsafe fn strncpy(
    dst: *mut libc::c_char,
    src: *const libc::c_char,
    n: libc::size_t,
) -> *mut libc::c_char {
    libc::strncpy(dst, src, n)
}

#[linux_cc]
pub unsafe fn umask(mask: usize) -> usize {
    // Wrong but works fine.
    mask
}

#[linux_cc]
pub unsafe fn write(fd: libc::c_int, buf: *const libc::c_void, count: libc::c_uint) -> libc::c_int {
    libc::write(fd, buf, count)
}

#[inline]
unsafe fn local_stat_to_linux(buf: libc::stat) -> stat {
    stat {
        st_dev: buf.st_dev as _,
        st_ino: buf.st_ino as _,
        st_nlink: buf.st_nlink as _,
        st_mode: 0o777 as _,
        st_uid: buf.st_uid as _,
        st_gid: buf.st_gid as _,
        st_rdev: buf.st_rdev as _,
        st_size: buf.st_size as _,
        st_atime: (buf.st_atime / 10000000) as _,
        // st_atime_nsec: buf.st_atime_nsec as _,
        st_mtime: (buf.st_mtime / 10000000) as _,
        // st_mtime_nsec: buf.st_mtime_nsec as _,
        st_ctime: (buf.st_ctime / 10000000) as _,
        // st_ctime_nsec: buf.st_ctime_nsec as _,
        ..mem::zeroed()
    }
}

#[inline]
unsafe fn linux_path_to_windows(path: *const libc::c_char) -> CString {
    let path = CStr::from_ptr(path)
        .to_str()
        .unwrap() // Safety: it's a path.
        .chars()
        .map(|x| match x {
            '/' => '\\',
            c => c,
        })
        .collect::<String>();

    let path = path.trim_start_matches("\\\\?\\").to_string();

    // Safety: no null will be generated by our processing.
    CString::new(path).unwrap()
}

#[linux_cc]
pub unsafe fn lstat(path: *const libc::c_char, buf: *mut stat) -> libc::c_int {
    let mut local_buf = mem::zeroed();
    let return_code = libc::stat(linux_path_to_windows(path).as_ptr(), &mut local_buf);
    *buf = local_stat_to_linux(local_buf);
    return_code
}

#[linux_cc]
pub unsafe fn fstat(fildes: libc::c_int, buf: *mut stat) -> libc::c_int {
    let mut local_buf = mem::zeroed();
    let return_code = libc::fstat(fildes, &mut local_buf);
    *buf = local_stat_to_linux(local_buf);
    return_code
}

#[linux_cc]
pub unsafe fn open(path: *const libc::c_char, oflag: libc::c_int) -> libc::c_int {
    let mut local_flag = 0x8000;

    if oflag & 0b11 == O_WRONLY {
        local_flag = libc::O_RDWR;
    }
    if oflag & 0b11 == O_RDWR {
        local_flag = libc::O_RDWR;
    }
    if oflag & 0b11 == O_RDONLY {
        local_flag = libc::O_RDWR;
    }

    if oflag & O_CREAT != 0 {
        local_flag |= libc::O_CREAT;
    }
    if oflag & O_NOFOLLOW != 0 {
        // local_flag |= libc::O_NOFOLLOW;
    }

    libc::open(linux_path_to_windows(path).as_ptr(), local_flag)
}
